---
layout: post
title: go中map实现记录
date: 2022-06-30
tags: 设计与实现 
---

## go中的map实现思路

### 核心结构体
hmap的结构其实刚开始看起来其实还是比较复杂的，有不少的字段，具体字段如下图所示：

<img src="https://cdn.jsdelivr.net/gh/Albertchamberlain/Images@main/image-20220630235209516.png" alt="image-20220630235209516" style="zoom: 67%;" />

| 字段           | 解释                                                         |
| -------------- | ------------------------------------------------------------ |
| count          | 键值对的数量                                                 |
| B              | **2^B=len(buckets)**                                         |
| hash0          | hash因子                                                     |
| buckets        | 指向一个数组(连续内存空间)，数组的类型为[]bmap，bmap类型就是存在键值对的结构下面会详细介绍，这个字段我们可以称之为正常桶。**如下图所示** |
| **oldbuckets** | 扩容时，存放之前的buckets(Map扩容相关字段)                   |
| extra          | 溢出桶结构，正常桶里面某个bmap存满了，会使用这里面的内存空间存放键值对 |
| noverflow      | 溢出桶里bmap大致的数量                                       |
| nevacuate      | 分流次数，成倍扩容分流操作计数的字段(Map扩容相关字段)        |
| **flags**      | 状态标识，比如正在被写、buckets和oldbuckets在被遍历、等量扩容(Map扩容相关字段) |



下面详细介绍一些字段

1. **buckets**

   ![image-20220630234038448](https://cdn.jsdelivr.net/gh/Albertchamberlain/Images@main/image-20220630234038448.png)

​	`buckets`指向了一个数组(连续的内存空间)，数组的元素是`bmap`类型，这个字段我们称之为正常桶。

`hmap`的源码和地址如下：

```go
// https://github.com/golang/go/blob/go1.13.8/src/runtime/map.go
type hmap struct {
    count     int 
    flags     uint8
    B         uint8 
    noverflow uint16 
    hash0     uint32
    buckets    unsafe.Pointer
    oldbuckets unsafe.Pointer
    nevacuate  uintptr 
    extra *mapextra
}
```

2. **bmap**

   正常桶`hmap.buckets`的元素是一个`bmap`结构。`bmap`的具体字段如下图所示：

   ![image-20220630234240566](https://cdn.jsdelivr.net/gh/Albertchamberlain/Images@main/image-20220630234240566.png)

字段释义如下：

| 字段     | 解释                                                         |
| -------- | ------------------------------------------------------------ |
| topbits  | 长度为8的数组，[]uint8，元素为：key获取的hash的高8位，遍历时对比使用，提高性能。**如下图所示** |
| keys     | 长度为8的数组，[]keytype，元素为：具体的key值。**如下图所示** |
| elems    | 长度为8的数组，[]elemtype，元素为：键值对的key对应的值。**如下图所示** |
| overflow | 指向的`hmap.extra.overflow`溢出桶里的`bmap`，上面的字段`topbits`、`keys`、`elems`长度为8，最多存8组键值对，存满了就往指向的这个`bmap`里存 |
| pad      | 对齐内存使用的，不是每个bmap都有会这个字段，需要满足一定条件 |

<img src="http://cdn.tigerb.cn/20201216202224.png" alt="img" style="zoom: 33%;" />

**每个`bmap`结构最多存放8组键值对。**



3. hamp和bmap的基本结构结合

   <img src="http://cdn.tigerb.cn/20201216202349.png" alt="img" style="zoom: 33%;" />

  4. 溢出桶

     上文提到`bmap`的时候，我们不是得到了个结论么“每个`bmap`结构最多存放8组键值对。”，所以问题来了：

     > 正常桶里的`bmap`存满了怎么办?

     解决这个问题我们就要说到`hmap.extra`结构了，`hmap.extra`是个结构体，结构图示和字段释义如下：

<img src="https://cdn.jsdelivr.net/gh/Albertchamberlain/Images@main/20201216202608.png" alt="img" style="zoom:50%;" />

| 字段         | 解释                                                         |
| ------------ | ------------------------------------------------------------ |
| overflow     | 称之为**溢出桶**。和`hmap.buckets`的类型一样也是数组`[]bmap`，当正常桶`bmap`存满了的时候就使用`hmap.extra.overflow`的`bmap`。所以这里有个问题正常桶`hmap.buckets`里的`bmap`是**如何关联**上溢出桶`hmap.extra.overflow`的`bmap` |
| oldoverflow  | 扩容时存放之前的overflow(Map扩容相关字段)                    |
| nextoverflow | 指向溢出桶里下一个可以使用的`bmap`                           |

源码和地址如下：

```go
// https://github.com/golang/go/blob/go1.13.8/src/runtime/map.go
type mapextra struct {
    overflow    *[]*bmap
    oldoverflow *[]*bmap
    nextOverflow *bmap
}
```

**如何关联？**

`bmap`结构时里的`bmap.overflow`字段(如下图所示)。`bmap.overflow`是个指针类型，存放了对应使用的溢出桶`hmap.extra.overflow`里的`bmap`的地址。

<img src="https://cdn.jsdelivr.net/gh/Albertchamberlain/Images@main/20201221131007.png" alt="img" style="zoom:50%;" />

**什么时候关联？**

在Map写操作的时候

```go
// https://github.com/golang/go/blob/go1.13.8/src/runtime/map.go
func mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {
  // 略
again:
    // 略...
    var inserti *uint8
  // 略...
bucketloop:
    for {
        for i := uintptr(0); i < bucketCnt; i++ {
      // key的hash高8位不相等
            if b.tophash[i] != top {
        // 当前位置bmap.tophash的元素为空且还没有写入的记录(inserti已经写入的标记为)
                if isEmpty(b.tophash[i]) && inserti == nil {
          // inserti赋值为当前的hash高8位 标记写入成功
                    inserti = &b.tophash[i]
                    // 略...
                }
                // 略...
                continue
            }
            // 略...
            goto done
    }
    // 正常桶的bmap遍历完了 继续遍历溢出桶的bmap 如果有的话
        ovf := b.overflow(t)
        if ovf == nil {
            break
    }
        b = ovf
    }

  // 略...

  // 没写入成功(包含正常桶的bmap、溢出桶的bmap(如果有的话))
    if inserti == nil {
    // 分配新的bmap写
    newb := h.newoverflow(t, b)
    // 略...
    }

    // 略...
}

// 继续看h.newoverflow的代码
func (h *hmap) newoverflow(t *maptype, b *bmap) *bmap {
  var ovf *bmap
  // 如果hmap的存在溢出桶 且 溢出桶还没用完
    if h.extra != nil && h.extra.nextOverflow != nil {
    // 使用溢出桶的bmap
    ovf = h.extra.nextOverflow
    // 判断桶的bmap的overflow是不是空
    // 这里很巧妙。为啥？
    // 溢出桶初始化的时候会把最后一个bmap的overflow指向正常桶，值不为nil
    // 目的判断当前这个bmap是不是溢出桶里的最后一个
        if ovf.overflow(t) == nil {
      // 是nil
      // 说明不是最后一个
            h.extra.nextOverflow = (*bmap)(add(unsafe.Pointer(ovf), uintptr(t.bucketsize)))
        } else {
      // 不是nil
      // 则重置当前bmap的overflow为空
      ovf.setoverflow(t, nil)
      // 且 标记nextOverflow为nil 说明当前溢出桶用完了
            h.extra.nextOverflow = nil
        }
    } else {
    // 没有溢出桶 或者 溢出桶用完了
    // 内存空间重新分配一个bmap
        ovf = (*bmap)(newobject(t.bucket))
  }
  // 生成溢出桶bmap的计数器计数
    h.incrnoverflow()
  // 略...
  // 这行代码就是上面问题我们要的答案:
  // 正常桶`hmap.buckets`里的`bmap`在这里关联上溢出桶`hmap.extra.overflow`的`bmap`
    b.setoverflow(t, ovf)
    return ovf
}

// setoverflow函数的源码
func (b *bmap) setoverflow(t *maptype, ovf *bmap) {
  // 这行代码的意思：通过偏移量计算找到了bmap.overflow，并把ovf这个bmap的地址赋值给了bmap.overflow
    *(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize)) = ovf
}
```

下面代码这段代码解释了，上面的源码中为何如此判断预分配溢出桶的`bmap`是最后一个的原因。

```go
// https://github.com/golang/go/blob/go1.13.8/src/runtime/map.go
// 创建hmap的正常桶
func makeBucketArray(t *maptype, b uint8, dirtyalloc unsafe.Pointer) (buckets unsafe.Pointer, nextOverflow *bmap) {
  // 略...
    if base != nbuckets {
    // 略...
    last := (*bmap)(add(buckets, (nbuckets-1)*uintptr(t.bucketsize)))
    // 把溢出桶里 最后一个 `bmap`的`overflow`指先正常桶的第一个`bmap`
    // 获取预分配的溢出桶里`bmap`时，可以通过判断overflow是不是为nil判断是不是最后一个
        last.setoverflow(t, (*bmap)(buckets))
  }
  // 略...
}
```

**当`hmap`存在溢出桶时，且当前溢出桶只被使用了一个bmap**时，我们可以得到如下的关系图：

<img src="https://cdn.jsdelivr.net/gh/Albertchamberlain/Images@main/20201217165310.png" alt="img" style="zoom: 33%;" />

同时我们可以看出正常桶的`bmap`和溢出桶的`bmap`实际构成了链表关系，所以这也解释了开篇我们说到的“Go里面Map的实现**主要**用到了数组”，其次还用到了**链表**。



### Summ

读取一个key的大致过程如下

<img src="http://cdn.tigerb.cn/20201217165551.png" alt="img" style="zoom:33%;" />



